/*! @file AgentContainer.H
    \brief Contains #AgentContainer class and related structs
*/
#ifndef AGENT_CONTAINER_H_
#define AGENT_CONTAINER_H_

#include <vector>
#include <string>
#include <array>

#include <AMReX_BoxArray.H>
#include <AMReX_DistributionMapping.H>
#include <AMReX_Geometry.H>
#include <AMReX_GpuDevice.H>
#include <AMReX_IntVect.H>
#include <AMReX_Particles.H>
#include <AMReX_iMultiFab.H>
#include <AMReX_Vector.H>

#include "AgentDefinitions.H"
#include "DiseaseParm.H"
#include "DiseaseStatus.H"
#include "HospitalModel.H"
#include "InteractionModelLibrary.H"


/*! \brief Derived class from ParticleContainer that defines agents and their functions */
class AgentContainer
    : public amrex::ParticleContainer<0, 0, RealIdx::nattribs, IntIdx::nattribs>
{

    using PCType = AgentContainer;
    using PType = ParticleType;
    using PTileType = ParticleTileType;
    using PTDType = PTileType::ParticleTileDataType;
    using IntModel = InteractionModel<PCType, PTDType, PType>;

    using MFPtr = std::unique_ptr<MultiFab>;
    using MFPtrVec = std::vector<MFPtr>;

public:

    AgentContainer (const amrex::Geometry            & a_geom,
                    const amrex::DistributionMapping & a_dmap,
                    const amrex::BoxArray            & a_ba,
                    const int                        & a_num_diseases,
                    const std::vector<std::string>   & a_disease_names);

    void morningCommute(amrex::MultiFab&);

    void eveningCommute(amrex::MultiFab&);

    void interactDay(amrex::MultiFab&);

    void interactEvening(amrex::MultiFab&);

    void interactNight(amrex::MultiFab&);

    void moveAgentsRandomWalk ();

    void moveRandomTravel (const amrex::Real random_travel_prob);

    void returnRandomTravel ();

    void updateStatus (MFPtrVec&);

    void infectAgents ();

    void shelterStart ();

    void shelterStop ();

    void generateCellData (amrex::MultiFab& mf) const;

    std::array<amrex::Long, 9> getTotals (const int);

    int getMaxGroup(const int group_idx);

    void moveAgentsToWork ();

    void moveAgentsToHome ();

    /*! \brief Return flag indicating if agents are at work */
    inline bool isAtWork() const {
        return m_at_work;
    }

    /*! \brief Return disease parameters object pointer (host) */
    inline const DiseaseParm* getDiseaseParameters_h (int d /*!< disease index */) const {
        return m_h_parm[d];
    }

    /*! \brief Return disease parameters object pointer (device) */
    inline const DiseaseParm* getDiseaseParameters_d (int d /*!< disease index */) const {
        return m_d_parm[d];
    }

    /*! \brief Return the number of diseases */
    inline int numDiseases() const {
        return m_num_diseases;
    }

    /* Since read_workerflow update worker status Unit-wise and not community-wise - Get total teacher needed for each unit */
    inline const amrex::Gpu::DeviceVector<int>& getUnitTeacherCounts() const {
        return m_unit_teacher_counts_d;
    }
    inline const amrex::Gpu::DeviceVector<int>& getCommDayCrTeacherCounts() const {
        return m_comm_teacher_counts_daycr_d;
    }
    inline const amrex::Gpu::DeviceVector<int>& getCommHighTeacherCounts() const {
        return m_comm_teacher_counts_high_d;
    }
    inline const amrex::Gpu::DeviceVector<int>& getCommMiddleTeacherCounts() const {
        return m_comm_teacher_counts_middle_d;
    }
    inline const amrex::Gpu::DeviceVector<int>& getCommElem3TeacherCounts() const {
        return m_comm_teacher_counts_elem3_d;
    }
    inline const amrex::Gpu::DeviceVector<int>& getCommElem4TeacherCounts() const {
        return m_comm_teacher_counts_elem4_d;
    }
    inline const amrex::Gpu::DeviceVector<int>& getCommTeacherCounts() const {
        return m_comm_teacher_counts_total_d;
    }

    /*! \brief return the symptomatic withdrawal status */
    inline int symptomaticWithdraw() const {
        return m_symptomatic_withdraw;
    }

    /*! \brief return the symptomatic withdrawal compliance */
    inline amrex::Real symptomaticWithdrawCompliance() const {
        return m_symptomatic_withdraw_compliance;
    }

    amrex::iMultiFab m_student_counts;
    amrex::Gpu::DeviceVector<int> m_unit_teacher_counts_d;
    amrex::Gpu::DeviceVector<int> m_comm_teacher_counts_total_d;
    amrex::Gpu::DeviceVector<int> m_comm_teacher_counts_high_d;
    amrex::Gpu::DeviceVector<int> m_comm_teacher_counts_middle_d;
    amrex::Gpu::DeviceVector<int> m_comm_teacher_counts_elem3_d;
    amrex::Gpu::DeviceVector<int> m_comm_teacher_counts_elem4_d;
    amrex::Gpu::DeviceVector<int> m_comm_teacher_counts_daycr_d;
    std::vector<long> m_student_teacher_ratios = {20, 20, 20, 20, 20, 1000000000}; // ignore daycare teachers since daycare interaction isnt handled yet!

    int m_num_diseases; /*!< Number of diseases */
    std::vector<std::string> m_disease_names; /*!< names of the diseases */

protected:

    int m_symptomatic_withdraw = 1; /*!< whether symptomatic agents withdraw or not */

    amrex::Real m_shelter_compliance = 0.95_rt; /*!< Shelter-in-place compliance rate */
    amrex::Real m_symptomatic_withdraw_compliance = 0.95_rt; /*!< Symptomatic withdrawal compliance rate */

    std::vector<DiseaseParm*> m_h_parm;    /*!< Disease parameters */
    std::vector<DiseaseParm*> m_d_parm;    /*!< Disease parameters (GPU device) */

    /*! Map of home bins (of agents) indexed by MultiFab iterator and tile index;
        see AgentContainer::interactAgentsHomeWork() */
    std::map<std::pair<int, int>, amrex::DenseBins<PTDType> > m_bins_home;
    /*! Map of work bins (of agents) indexed by MultiFab iterator and tile index;
        see AgentContainer::interactAgentsHomeWork() */
    std::map<std::pair<int, int>, amrex::DenseBins<PTDType> > m_bins_work;
    /*! Map of random travel bins (of agents) indexed by MultiFab iterator and tile index;
        see AgentContainer::interactAgentsRandom() */
    std::map<std::pair<int, int>, amrex::DenseBins<PTDType> > m_bins_random;

    std::map<std::string, IntModel*> m_interactions; /*!< Map of interaction models */
    std::unique_ptr<HospitalModel<PCType, PTDType, PType>> m_hospital; /*!< hospital model */

    /*! Flag to indicate if agents are at work */
    bool m_at_work;

    /*! Disease status update model */
    DiseaseStatus<PCType,PTileType,PTDType,PType> m_disease_status;

    Array<int, IntIdx::nattribs> max_attribute_values;

    /*! \brief queries if a given interaction type (model) is available */
    inline bool haveInteractionModel( const std::string& a_mod_name ) const {
        return (m_interactions.find(a_mod_name) != m_interactions.end());
    }

    /*! \brief Add runtime SoA attributes */
    void add_attributes();
};

using AgentIterator = typename AgentContainer::ParIterType;

#endif
